(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{348:function(n,t,a){n.exports=a.p+"assets/img/1.81d60a3a.jpeg"},588:function(n,t,a){"use strict";a.r(t);var e=a(56),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"你不知道的-js-读书笔记-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#你不知道的-js-读书笔记-6"}},[n._v("#")]),n._v(" 你不知道的 JS 读书笔记 6")]),n._v(" "),e("img",{attrs:{src:a(348)}}),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("  undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名称既是类型也是值。undefined 和 null 常被用来表示空的值或是不是值的值。null 指空值（empty value)。undefined 指没有值（missing value)或者 undefined 指从未赋值。null 指曾赋过值，但是目前没有值。null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。")]),n._v(" "),e("p",[n._v("  NaN 意指不是一个数字。这个名字容易引起误会，将它理解为无效数值，失败数值或者坏数值可能更准确些。我们可以使用内建的全局工具函数 isNaN(...)来判断一个值是否是 NaN。isNan(...)有一个严重的缺陷，它的检查方式过于死板，就是检查参数是否不是 Nan,也不是数字。我们可以使用工具函数 Number.isNan(...)。")]),n._v(" "),e("p",[n._v('  JSON.stringify(-0)返回 0,而 JSON.parse("-0")返回-0。而-0 等于 0，因此我们必须使用 isNegZero(...)这样的工具函数。Object.is(...)来判断两个值是否绝对相等，可以用来处理上述所有的特殊情况:object.is(a,NaN)//true,Object.is(b,-0)//true')]),n._v(" "),e("p",[n._v("  Javascript 中没有指针，引用的工作机制也不尽相同。在 js 中变量不可能成为指向另一个变量的引用。js 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用/指向关系。js 对值和引用的赋值/传递在语法上没有区别，完全根据值的类型来决定。")]),n._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("var")]),n._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[n._v("Array")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[n._v("apply")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[n._v("length")]),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[n._v("3")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\na "),e("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// [undefined,undefined,undefined]")]),n._v("\n")])])]),e("p",[n._v("  apply(...)是一个工具函数，适用于所有函数对象，它会以一种特殊的方式来调用传递给它的函数。第一个参数是this对象，这里不用费心，暂将它设为null。第二个参数则必须是一个数组，其中的值被用作函数的参数。于是Array.apply(...)调用Array(...)函数，并且将{length:3}作为函数的参数。我们可以设想apply(...)内部有一个for循环。从0开始循环到length。假设在apply(...)内部该数组参数名为arr,for循环就会这样来遍历数组：arr[0],arr[1],arr[2]。然而，由于{length:3}并不存在这些属性，所以返回值为undefined。换句话说，我们执行的实际上是Array(undefined,undefined,undefined),所以结果是单元值为undefined的数组，而非空单元数组。虽然Array.apply(null,{length:3})在创建undefined值的数组有些奇怪和繁琐，但是其结果远比Array(3)更准确可靠。总之，永远不要创建和使用空单元数组。")]),n._v(" "),e("p",[n._v("  同样，除非万不得已，否则尽量不要使用Object(...)/Function(...)/RegExp(...)")]),n._v(" "),e("p",[n._v("  相较于其他原生构造函数，Date(...)和Error(...)的用处要大很多，因为没有对应的常量形式来作为它们的替代。")]),n._v(" "),e("p",[n._v("  将值从一种类型转换为另一种类型通常称为类型转换，这是显式的情况；隐式的情况称为强制类型转换。也可以这样来区分：类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时。然而js中通常将它们统称为强制类型转换，我个人倾向于隐式强制类型转换和显式强制类型转换来区分。我们能够从代码中看出哪些地方是显式强制类型转换，而隐式强制类型转换则不那么明显，通常是某些操作产生的副作用。")]),n._v(" "),e("p",[n._v("  为了简单起见，我们来看看什么是不安全的JSON值。undefined，function,symbol和包含循环引用的对象都不符合JSON结构标准，其他支持JSON的语言无法处理它们。")])])}),[],!1,null,null,null);t.default=s.exports}}]);