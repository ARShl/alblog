(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{354:function(t,s,a){t.exports=a.p+"assets/img/31.7a410964.jpeg"},495:function(t,s,a){"use strict";a.r(s);var e=a(56),l=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"《javascript-悟道》-读书笔记2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#《javascript-悟道》-读书笔记2"}},[t._v("#")]),t._v(" 《Javascript 悟道》 读书笔记2")]),t._v(" "),e("img",{attrs:{src:a(354)}}),t._v(" "),e("p"),t._v(" "),e("hr"),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("只让构造函数有一个参数。这个参数书一个对象，通常是以对象字面量的形式传入的，但有时候也可以来自其他代码源，如JSON数据。这么做有几个好处：键名可以让代码本身成为文档，当我们读到代码的时候，就能明白每个字段的含义；参数无需按顺序传入；以后可以无痛新增参数;过时的参数会被忽略，并不一定要删除。")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  function my_little_constructor(spec){\n    let { name , mana_cost, colors}  = spec\n  }\n")])])]),e("blockquote",[e("ul",[e("li",[t._v("当一个函数返回另一个函数的返回值时，我们就称其是一个尾调用。说起来真可笑，我们居然不称其为返回调用。")]),t._v(" "),e("li",[t._v("顺序化编程语言的一个典型特征就是会阻塞输入输出。当程序试图从文件或者网络读取内容时，程序就会被阻塞，直到读取操作完成。Js的首要任务是与人类交互，所以需要一个更好的模型。")]),t._v(" "),e("li",[t._v("事件函数是一种会立即返回的函数，可能在其要求的工作完成前就返回。它的结果通常不会直接返回，而是通过回调函数或者消息来与关心方通信。")]),t._v(" "),e("li",[t._v("性能元凶：无法并行化。违反回合法则。低内聚性。高耦合性。错误算法。缓存抖动。代码膨胀。第三方代码。")])])])])}),[],!1,null,null,null);s.default=l.exports}}]);